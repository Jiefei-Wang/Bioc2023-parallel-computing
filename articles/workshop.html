<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>High-Performance Computing in R for Genomic Research • EZParallel</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="High-Performance Computing in R for Genomic Research">
<meta property="og:description" content="EZParallel">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">EZParallel</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">2.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/HOWTO_BUILD_WORKSHOP.html">How To Build A Workshop Package</a>
    </li>
    <li>
      <a href="../articles/workshop.html">High-Performance Computing in R for Genomic Research</a>
    </li>
    <li>
      <a href="../articles/workshop_example.html">An Example Workshop</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/seandavi/BuildABiocWorkshop" class="external-link">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>High-Performance Computing in R for Genomic
Research</h1>
                        <h4 data-toc-skip class="author">Sean Davis<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>
</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/Jiefei-Wang/Bioc2023-parallel-computing/blob/HEAD/vignettes/workshop.Rmd" class="external-link"><code>vignettes/workshop.Rmd</code></a></small>
      <div class="hidden name"><code>workshop.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="high-performance-computing-in-r-for-genomic-research">High-Performance Computing in R for Genomic Research<a class="anchor" aria-label="anchor" href="#high-performance-computing-in-r-for-genomic-research"></a>
</h2>
<p>Authors: Jiefei Wang<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. <br> Last modified: 12 July, 2023</p>
<div class="section level3">
<h3 id="overview">Overview<a class="anchor" aria-label="anchor" href="#overview"></a>
</h3>
<div class="section level4">
<h4 id="description">Description<a class="anchor" aria-label="anchor" href="#description"></a>
</h4>
<p>In this vignette, we will introduce the basic concepts of parallel
computing and how to use parallel computing in R. We will also introduce
the BiocParallel package and how to use it to speed up your analysis.
This is a lecture + lab workshop, most content in this vignette will be
covered in the lecture slides. This vignette serves as a reference for
the workshop. In this lecture, no prior knowledge of parallel computing
is required, but basic knowledge of R syntax is needed to complete this
workshop.</p>
</div>
<div class="section level4">
<h4 id="participation">Participation<a class="anchor" aria-label="anchor" href="#participation"></a>
</h4>
<p>To follow the lecture, you can either use your own Rstudio and
install the required package, or use the Rstudio cloud at <a href="https://workshop.bioconductor.org/" class="external-link">Bioconductor Workshop
Galaxy</a> (recommended). The Rstudio cloud is free to use, but you need
to register an account first.</p>
</div>
<div class="section level4">
<h4 id="r-bioconductor-packages-used">
<em>R</em> / <em>Bioconductor</em> packages used<a class="anchor" aria-label="anchor" href="#r-bioconductor-packages-used"></a>
</h4>
<ol style="list-style-type: decimal">
<li>parallel</li>
<li>BiocParallel</li>
<li>RedisParam</li>
<li>SharedObject</li>
<li>delayedXX</li>
</ol>
</div>
<div class="section level4">
<h4 id="useful-materials">Useful Materials<a class="anchor" aria-label="anchor" href="#useful-materials"></a>
</h4>
<ol style="list-style-type: decimal">
<li><a href="https://bioconductor.org/packages/release/bioc/vignettes/BiocParallel/inst/doc/Introduction_To_BiocParallel.html" class="external-link">Introduction
to BiocParallel</a></li>
<li><a href="https://bioconductor.org/packages/release/bioc/vignettes/BiocParallel/inst/doc/Random_Numbers.html" class="external-link">Random
Numbers in BiocParallel</a></li>
<li><a href="https://bioconductor.org/packages/release/bioc/vignettes/BiocParallel/inst/doc/Errors_Logs_And_Debugging.pdf" class="external-link">Errors,
Logs and Debugging in BiocParallel</a></li>
<li>Jiefei Wang’s email: <a href="mailto:jiewang@utmb.edu" class="email">jiewang@utmb.edu</a> (Questions, discussions, and
collaborations are welcome)</li>
</ol>
</div>
<div class="section level4">
<h4 id="time-outline">Time outline<a class="anchor" aria-label="anchor" href="#time-outline"></a>
</h4>
<p>An example for a 45-minute workshop:</p>
<table class="table">
<thead><tr class="header">
<th>Activity</th>
<th>Time</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Introduction</td>
<td>20m</td>
</tr>
<tr class="even">
<td>Naive way of Parallalization</td>
<td>10m</td>
</tr>
<tr class="odd">
<td>Bioconductor way of Parallalization</td>
<td>20m</td>
</tr>
<tr class="even">
<td>Performance Improvement</td>
<td>20m</td>
</tr>
<tr class="odd">
<td>Debug</td>
<td>20m</td>
</tr>
<tr class="even">
<td>Practice</td>
<td>10m</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="workshop-goals-and-objectives">Workshop goals and objectives<a class="anchor" aria-label="anchor" href="#workshop-goals-and-objectives"></a>
</h4>
<p>List “big picture” student-centered workshop goals and learning
objectives. Learning goals and objectives are related, but not the same
thing. These goals and objectives will help some people to decide
whether to attend the conference for training purposes, so please make
these as precise and accurate as possible.</p>
<p><em>Learning goals</em> are high-level descriptions of what
participants will learn and be able to do after the workshop is over.
<em>Learning objectives</em>, on the other hand, describe in very
specific and measurable terms specific skills or knowledge attained. The
<a href="#bloom">Bloom’s Taxonomy</a> may be a useful framework for
defining and describing your goals and objectives, although there are
others.</p>
</div>
<div class="section level4">
<h4 id="learning-goals">Learning goals<a class="anchor" aria-label="anchor" href="#learning-goals"></a>
</h4>
<ul>
<li>Understanding different parallel computing backend</li>
<li>Knowing how to use BiocParallel package to speed up your
analysis</li>
<li>(Advanced) Being able to do build your at-home computing
cluster</li>
</ul>
</div>
<div class="section level4">
<h4 id="learning-objectives">Learning objectives<a class="anchor" aria-label="anchor" href="#learning-objectives"></a>
</h4>
<ul>
<li>Experience R build-in <em>parallel</em> package</li>
<li>Experience Bioconducotr <em>BiocParallel</em> package</li>
<li>Set up computing backend</li>
<li>Run Simulation in parallel</li>
</ul>
</div>
</div>
<div class="section level3">
<h3 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h3>
<p>While parallel computing may sound fancy and complicated, it is
actually very simple at its core. For example, if you need to perform
1000 additions, you can either do it one by one by yourself, or you can
ask 10 friends to do 100 additions each(be sure to treat them a nice
dinner afterwards). If you choose the latter, you are doing parallel
computing. In computer science, we usually call you the “master” and
your friends the “workers”.</p>
<p>Without loss of generality, a parallel computing in R involves the
following steps: 1. Start a master process 2. Start worker processes 3.
split a job into smaller tasks 4. send tasks to workers 5. receive and
combine results from workers</p>
<p>The master process and the worker processes can be on the same
computer or on different computers. In practice, there is no need to
worry about the technical details of each step as most of these steps
are handled by R parallel packages. Instead, you need to focus on some
high-level questions: 1. Where to find the workers? 2. How many workers
do you need? 3. How do you communicate between the master and the
workers? 4. How do you combine the results from workers?</p>
<p>These questions are the big picture of parallel computing. You will
find most parallel packages only differ in the design of their syntax,
but the big picture is the same. If you have a clear answer to those
questions, you are ready to do parallel computing in R.</p>
<div class="section level4">
<h4 id="popular-r-parallel-packages">Popular R parallel packages<a class="anchor" aria-label="anchor" href="#popular-r-parallel-packages"></a>
</h4>
<p>There are many parallel packages in R, here are some of the most
popular ones: 1. parallel 2. foreach 3. BiocParallel 4. future</p>
<p>In this workshop, we will briefly introduce the parallel package and
focus on the BiocParallel package.</p>
</div>
</div>
<div class="section level3">
<h3 id="naive-way-of-parallalization">Naive way of Parallalization<a class="anchor" aria-label="anchor" href="#naive-way-of-parallalization"></a>
</h3>
<p>The <strong>parallel</strong> package is perhaps the most basic
parallel package in R. It is a build-in package, so you don’t need to
install it. It is a good starting point to enter the world of high
performance computing. Suppose you have code as follow</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## A function that takes a long time to run</span></span>
<span><span class="va">foo</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">x</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, <span class="va">foo</span><span class="op">)</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [1] 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [1] 9</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [1] 16</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[5]]</span></span>
<span><span class="co">#&gt; [1] 25</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[6]]</span></span>
<span><span class="co">#&gt; [1] 36</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[7]]</span></span>
<span><span class="co">#&gt; [1] 49</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[8]]</span></span>
<span><span class="co">#&gt; [1] 64</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[9]]</span></span>
<span><span class="co">#&gt; [1] 81</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[10]]</span></span>
<span><span class="co">#&gt; [1] 100</span></span></code></pre></div>
<p>In this artificial example, we have a function foo that will sleep
for 1 second and then return the square of the input. We then apply this
function to a vector of 10 numbers. If you run this code, the function
<strong>foo</strong> will be executed 10 times and costs us 10 seconds
to finish. In practice, you will replace the function
<strong>foo</strong> with your own function that does the real work.
Now, let’s try to parallelize this code using the parallel package.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Load the parallel package</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">parallel</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Define 10 workers</span></span>
<span><span class="va">cl</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">makeCluster</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## dispath the job to workers, </span></span>
<span><span class="co">## each of them will execute foo once</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">parLapply</a></span><span class="op">(</span><span class="va">cl</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, <span class="va">foo</span><span class="op">)</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [1] 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [1] 9</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [1] 16</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[5]]</span></span>
<span><span class="co">#&gt; [1] 25</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[6]]</span></span>
<span><span class="co">#&gt; [1] 36</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[7]]</span></span>
<span><span class="co">#&gt; [1] 49</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[8]]</span></span>
<span><span class="co">#&gt; [1] 64</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[9]]</span></span>
<span><span class="co">#&gt; [1] 81</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[10]]</span></span>
<span><span class="co">#&gt; [1] 100</span></span></code></pre></div>
<p>In this revised version, we loaded the <strong>parallel</strong>
package and defined 10 workers at the first two lines of the code. The
variable <strong>cl</strong> is a cluster object that refers to the 10
workers. Then we used the <strong>parLapply</strong> function to
dispatch the job to the workers. The <strong>parLapply</strong> function
is very similar to the <strong>lapply</strong> function, except that it
will dispatch the job to the workers. Since we want to run
<strong>foo</strong> 10 times and we have 10 workers, each worker will
run <strong>foo</strong> once. You will find that it will take roughly 1
second for <strong>parLapply</strong> to finish.</p>
<p>Congradulations! You have done your first parallel computing in R!
Now, it is the time to think about the big picture questions. We have
implemented parallel computing without answering any of those questions.
Let’s try to answer those questions one by one.</p>
<ol style="list-style-type: decimal">
<li><p><strong>Where to find the workers</strong>: You can possibly
guess the answer to this question, we create 10 workers on the same
computer as the master process. There is no magic in computer science,
if you have one computer running your R code, there is no way for R to
“enslaves” your neighbor’s computers to do your homework. So, the
workers must be on the same computer as the master process.</p></li>
<li><p><strong>How many workers do you need</strong>: The answer to this
question usually determined by the number of cores and memory size on
your computer. In this example, we can have as many workers as we want
because the function <strong>foo</strong> only uses negligible
resources. In practice, you should use the number of cores on your
computer as the number of workers if possible and reduce the worker
number if your code is memory intensive.</p></li>
<li><p><strong>How do you communicate between the master and the
workers</strong>: It will be trivial to think about this question if the
master and the workers are on the same computer. However, the question
will be important if you want to build a computing cluster and utilize
the computing power of multiple computers. In this example, we are using
a network protocal named SNOW to communicate between the master and the
workers. You don’t need to worry about the details of the socket
protocal, but you need to know that it is a network protocal so the same
code will work even if the master and the workers are on different
computers given that you can connect to the workers correctly.</p></li>
<li><p><strong>How do you combine the results from workers</strong>: In
this example, the <strong>parLapply</strong> function will automatically
combine the results from the workers and return a list. Depending on
your expected output, you may want to use <strong>parSapply</strong> or
<strong>parApply </strong> instead.</p></li>
</ol>
</div>
<div class="section level3">
<h3 id="bioconductor-way-of-parallalization">Bioconductor way of Parallalization<a class="anchor" aria-label="anchor" href="#bioconductor-way-of-parallalization"></a>
</h3>
<div class="section level4">
<h4 id="snowparam">SnowParam<a class="anchor" aria-label="anchor" href="#snowparam"></a>
</h4>
<p>The <strong>BiocParallel</strong> package is a parallel package
developed by the Bioconductor team. It is highly customizable and
actively maintained. Again, assume we have a function
<strong>foo</strong> that takes a long time to run. We can use the
<strong>BiocParallel</strong> package to parallelize it as follow:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Load the BiocParallel package</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Bioconductor/BiocParallel" class="external-link">BiocParallel</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Define 10 workers</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/SnowParam-class.html" class="external-link">SnowParam</a></span><span class="op">(</span>worker <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## dispath the job to workers, </span></span>
<span><span class="co">## each of them will execute foo once</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, <span class="va">foo</span>, BPPARAM <span class="op">=</span> <span class="va">param</span><span class="op">)</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [1] 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [1] 9</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [1] 16</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[5]]</span></span>
<span><span class="co">#&gt; [1] 25</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[6]]</span></span>
<span><span class="co">#&gt; [1] 36</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[7]]</span></span>
<span><span class="co">#&gt; [1] 49</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[8]]</span></span>
<span><span class="co">#&gt; [1] 64</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[9]]</span></span>
<span><span class="co">#&gt; [1] 81</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[10]]</span></span>
<span><span class="co">#&gt; [1] 100</span></span></code></pre></div>
<p>As you can see from the example, the usage of
<strong>BiocParallel</strong> is very similar to the
<strong>parallel</strong> package. In <strong>BiocParallel</strong>, we
use <strong>SnowParam</strong> to create workers. The function
explicitly states that we are going to use SNOW network protocal to
communicate between the master and the workers. The cluster we created
from <strong>SnowParam</strong> is called backend in
<strong>BiocParallel</strong>.</p>
<p>You might wonder why we need another parallel package if it is so
similar to the <strong>parallel</strong> package. The answer is that the
<strong>BiocParallel</strong> package is highly customizable.
<strong>BiocParallel</strong> allows you to set random seed in the
workers, set the progress bar, and many more things.</p>
</div>
<div class="section level4">
<h4 id="multicoreparam-linux-only">MulticoreParam (Linux only)<a class="anchor" aria-label="anchor" href="#multicoreparam-linux-only"></a>
</h4>
<p>For Linux users, you can use the <strong>MulticoreParam</strong> to
parallelize your code. The <strong>MulticoreParam</strong> is a special
type of <strong>param</strong> that will create multiple copies of the
master process to run your code. Each copy will share exactly the same
data as the master process, so creating a new worker will not cost you
too much memory. <strong>MulticoreParam</strong> is preferred over
<strong>SnowParam</strong> if you have a big dataset and want each work
own a copy of the data. The usage of <strong>MulticoreParam</strong> is
as follow:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Load the BiocParallel package</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Bioconductor/BiocParallel" class="external-link">BiocParallel</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Define 10 workers</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/MulticoreParam-class.html" class="external-link">MulticoreParam</a></span><span class="op">(</span>worker <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## dispath the job to workers, </span></span>
<span><span class="co">## each of them will execute foo once</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, <span class="va">foo</span>, BPPARAM <span class="op">=</span> <span class="va">param</span><span class="op">)</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [1] 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [1] 9</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [1] 16</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[5]]</span></span>
<span><span class="co">#&gt; [1] 25</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[6]]</span></span>
<span><span class="co">#&gt; [1] 36</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[7]]</span></span>
<span><span class="co">#&gt; [1] 49</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[8]]</span></span>
<span><span class="co">#&gt; [1] 64</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[9]]</span></span>
<span><span class="co">#&gt; [1] 81</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[10]]</span></span>
<span><span class="co">#&gt; [1] 100</span></span></code></pre></div>
<p>You can see that changing the backend only requres changing the
definition of the param. The rest of the code is the same. This modern
design allows you to easily share your code with others without worrying
about the backend that your collaborator is using.</p>
</div>
<div class="section level4">
<h4 id="redisparam">RedisParam<a class="anchor" aria-label="anchor" href="#redisparam"></a>
</h4>
<p>Now you know how to create a tiny cluster in your computer. However,
you may want to create a cluster with multiple computers. You will
quickly find that the <strong>SnowParam</strong> and
<strong>MulticoreParam</strong> are cumbersome for this task. Some
problems you may encounter are: 1. Each workers must have a public IP
address to access 2. You need to set up SSH server and keys for all
workers in order to start workers remotely 3. The workers are not
persistent, they will be killed when the master process quits.</p>
<p>These three problems hinder the usage of <strong>SnowParam</strong>
when handling larger computing cluster. <strong>RedisParam</strong> is
designed for this case. Instead of having a direct communication between
master and workers, <strong>RedisParam</strong> put a Redis server in
the middle. The role of the Redis server is similar to the role of
community-bioc Slack workspace. If you have a question(computing job)
and you want to get help from the other developers(workers). Do you want
to contact each developer individually? Possibly not, if we use this
mode to ask questions, you may need to send thousands of emails to get
the answer to your question. Meanwhile, our enthusiastic developers will
be overwhelmed by tons of question emails as well. To prevent that
happens, we have community-bioc Slack workspace stands in the middle
between developers. You are free to post any question you want to ask,
and our lovely developers will answer whatever question they can answer.
The similar thing happens to <strong>RedisParam</strong> as well. A
master process will send the job to the Redis server, and the Redis
server will dispatch the job to the workers. The workers will send the
results back to the Redis server, and the workers(if any) will retrieve
the results from the Redis server and perform the actual computation.
You can even have more than one master processes sharing a pool of
workers, just like you can have more than one developer asking questions
in the developer forum.</p>
<p>The use of <strong>RedisParam</strong> requires a little bit more
work. We need to set up a Redis server. The easiest way to do that is to
use the docker image of Redis. You can install docker from <a href="https://docs.docker.com/install/" class="external-link">here</a>. You will need
WSL2(Windows Subsystem for Linux) if you are using Windows. After you
have installed docker, you can run the following command to start a
Redis server.</p>
<pre><code>docker run --name my-first-redis -p 6379:6379 -d redis redis-server --requirepass "1234"</code></pre>
<p>The command above will start a Redis server on port 6379 with
password 1234. The port number 6379 is the default port used by the
Redis server.</p>
</div>
</div>
<div class="section level3">
<h3 id="run-master-and-workers-in-the-same-computer">Run master and workers in the same computer<a class="anchor" aria-label="anchor" href="#run-master-and-workers-in-the-same-computer"></a>
</h3>
<p>Running master and workers in the same computer is the simplest
way(and possibly overkill) to use RedisParam. You can use the following
code to create a RedisParam cluster.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">RedisParam</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Define 10 workers using Redis server</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/RedisParam/man/RedisParam-class.html" class="external-link">RedisParam</a></span><span class="op">(</span></span>
<span>  workers <span class="op">=</span> <span class="fl">10</span>,</span>
<span>  redis.password <span class="op">=</span> <span class="st">'1234'</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The code is really not that different from the SnowParam and
MulticoreParam. The RedisParam will create 10 workers that connect to
the Redis server on localhost(your computer) using the password
1234.</p>
<div class="section level4">
<h4 id="cloud-based-redis-server">Cloud-based Redis server<a class="anchor" aria-label="anchor" href="#cloud-based-redis-server"></a>
</h4>
<p>The real power of RedisParam comes in when you want to use a
cloud-based Redis server. However, there are a two things to consider
before you can use it.</p>
<ol style="list-style-type: decimal">
<li>the IP address of the Redis server.</li>
<li>The name of the job queue shared by master and workers</li>
</ol>
<p>Our computer uses IP address to communicate with each other. It’s
like the address of your house. If you want to send a letter to your
friend, you need to know the address of your friend. The same thing
happens to the Redis server. We need to know the IP address of the Redis
server in order to talk with Redis. The job queue is a new concept here.
Since we can have multiple master processes sharing the same pool of
workers, we need to have a way to distinguish the jobs from different
master processes. We still use Slack Workspace as an example. When you
post your question, you need to post it to a specific channel. All the
developers in the channel will see your question and answer it if they
can. A job queue in Redis is like a channel in Slack, a master process
will post its computing tasks to a specific job queue, and the workers
will retrieve the tasks from the job queue. Note that multiple master
processes can post their tasks to the same job queue. This way, multiple
master processes can share the same pool of workers.</p>
</div>
<div class="section level4">
<h4 id="start-workers">Start Workers<a class="anchor" aria-label="anchor" href="#start-workers"></a>
</h4>
<p>In this workshop, we will set up a remote Redis server for you. We
ask you to “donate” some workers to our demo job queue.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Redis server IP. To be announced in the workshop</span></span>
<span><span class="va">host</span> <span class="op">&lt;-</span> <span class="st">'remote-Ip-address'</span></span>
<span></span>
<span><span class="co">## Define how many worker you want to "donate"</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/RedisParam/man/RedisParam-class.html" class="external-link">RedisParam</a></span><span class="op">(</span></span>
<span>  workers <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  redis.hostname <span class="op">=</span> <span class="va">host</span>,</span>
<span>  redis.password <span class="op">=</span> <span class="st">'1234'</span>,</span>
<span>  jobname <span class="op">=</span> <span class="st">"demo"</span>,</span>
<span>  is.worker <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Start the worker</span></span>
<span><span class="co">## This will block the entire R session</span></span>
<span><span class="co">## You CANNOT use ctrl + c to stop the worker</span></span>
<span><span class="co">## Don't be panic, I will free you after a minute</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/BiocParallelParam-class.html" class="external-link">bpstart</a></span><span class="op">(</span><span class="va">param</span><span class="op">)</span></span></code></pre></div>
<p>A few things to note here. We use <strong>redis.hostname</strong> to
specify the IP address of the Redis server. We use
<strong>jobname</strong> to specify the job queue we want to use. The
job queue is identified by a character name. We use <strong>is.worker =
TRUE</strong> to tell RedisParam that we want to start two workers. If
FALSE, the argument <strong>workers</strong> will be ignored and
<strong>param</strong> will be used as a master.</p>
</div>
<div class="section level4">
<h4 id="start-a-master">Start a master<a class="anchor" aria-label="anchor" href="#start-a-master"></a>
</h4>
<p>Creating a master is similar to creating a worker. The only
difference is that we set <strong>is.worker = FALSE</strong>. We create
a random job name so that all of us can share the same Redis server to
do the computation.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Redis server IP. To be announced in the workshop</span></span>
<span><span class="va">host</span> <span class="op">&lt;-</span> <span class="st">'remote-Ip-address'</span></span>
<span></span>
<span><span class="co">## Create a ramdom jobname</span></span>
<span><span class="va">jobname</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/ipcmutex.html" class="external-link">ipcid</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Create a master param</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/RedisParam/man/RedisParam-class.html" class="external-link">RedisParam</a></span><span class="op">(</span></span>
<span>  redis.hostname <span class="op">=</span> <span class="va">host</span>,</span>
<span>  redis.password <span class="op">=</span> <span class="st">'1234'</span>,</span>
<span>  jobname <span class="op">=</span> <span class="va">jobname</span>,</span>
<span>  is.worker <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Note that this master param cannot be used to do the computation
right now, as the job queue is not monitored by any workers(you wouldn’t
expect to get any message from a Slack channel with no members, right?).
You need the code from the previous section to start your worker
elsewhere and connect with the same job queue. While the order of
starting the master and workers doesn’t matter, you need to have your
workers ready before you use your master param to do the actual
computation.</p>
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p><a href="mailto:seandavi@gmail.com" class="email">seandavi@gmail.com</a><a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>University of Texas Medical Branch at Galveston<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Jiefei Wang.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
