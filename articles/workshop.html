<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>High-Performance Computing in R for Genomic Research • EZParallel</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="High-Performance Computing in R for Genomic Research">
<meta property="og:description" content="EZParallel">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">EZParallel</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">2.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/workshop.html">High-Performance Computing in R for Genomic Research</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/seandavi/BuildABiocWorkshop" class="external-link">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>High-Performance Computing in R for Genomic
Research</h1>
                        <h4 data-toc-skip class="author">Jifei Wang<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>
</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/Jiefei-Wang/Bioc2023-parallel-computing/blob/HEAD/vignettes/workshop.Rmd" class="external-link"><code>vignettes/workshop.Rmd</code></a></small>
      <div class="hidden name"><code>workshop.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="high-performance-computing-in-r-for-genomic-research">High-Performance Computing in R for Genomic Research<a class="anchor" aria-label="anchor" href="#high-performance-computing-in-r-for-genomic-research"></a>
</h2>
<p>In this vignette, we will introduce the basic concepts of parallel
computing and how to use parallel computing in R. We will also introduce
the BiocParallel package and how to use it to speed up your analysis.
This is a lecture + lab workshop, most content in this vignette will be
covered in the lecture slides. This vignette serves as a reference for
the workshop. In this lecture, no prior knowledge of parallel computing
is required, but basic knowledge of R syntax is needed to complete this
workshop.</p>
<div class="section level3">
<h3 id="participation">Participation<a class="anchor" aria-label="anchor" href="#participation"></a>
</h3>
<p>To follow the lecture, you can either use your own Rstudio and
install the required package(see package DESCRIPTION), or use the
Rstudio at <a href="https://workshop.bioconductor.org/" class="external-link">Bioconductor
Workshop Galaxy</a> (recommended). The Rstudio is free to use, but you
need to register an account first.</p>
</div>
<div class="section level3">
<h3 id="parallel-computing-packages-in-r">Parallel Computing Packages in R<a class="anchor" aria-label="anchor" href="#parallel-computing-packages-in-r"></a>
</h3>
<p>There are many parallel packages in R, here are some of the most
popular ones:</p>
<ol style="list-style-type: decimal">
<li>parallel</li>
<li>foreach</li>
<li>BiocParallel</li>
<li>future</li>
</ol>
<p>In this workshop, we will focus on the BiocParallel package, which is
the official parallel package used in Bioconductor.</p>
</div>
<div class="section level3">
<h3 id="r-bioconductor-packages-used">
<em>R</em> / <em>Bioconductor</em> packages used<a class="anchor" aria-label="anchor" href="#r-bioconductor-packages-used"></a>
</h3>
<ol style="list-style-type: decimal">
<li>BiocParallel</li>
<li>RedisParam</li>
<li>SummarizedExperiment (in example only)</li>
<li>airway (in example only)</li>
<li>DESeq2 (in example only)</li>
</ol>
</div>
<div class="section level3">
<h3 id="useful-materials">Useful Materials<a class="anchor" aria-label="anchor" href="#useful-materials"></a>
</h3>
<ol style="list-style-type: decimal">
<li><a href="https://bioconductor.org/packages/release/bioc/vignettes/BiocParallel/inst/doc/Introduction_To_BiocParallel.html" class="external-link">Introduction
to BiocParallel</a></li>
<li><a href="https://bioconductor.org/packages/release/bioc/vignettes/BiocParallel/inst/doc/Random_Numbers.html" class="external-link">Random
Numbers in BiocParallel</a></li>
<li><a href="https://bioconductor.org/packages/release/bioc/vignettes/BiocParallel/inst/doc/Errors_Logs_And_Debugging.pdf" class="external-link">Errors,
Logs and Debugging in BiocParallel</a></li>
<li>Jiefei Wang’s email: <a href="mailto:szwjf08@gmail.com" class="email">szwjf08@gmail.com</a> (Questions, discussions, and
collaborations are welcome)</li>
</ol>
</div>
<div class="section level3">
<h3 id="time-outline">Time outline<a class="anchor" aria-label="anchor" href="#time-outline"></a>
</h3>
<table class="table">
<thead><tr class="header">
<th>Activity</th>
<th>Time</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Introduction</td>
<td>20m</td>
</tr>
<tr class="even">
<td>Parallelization using BiocParallel</td>
<td>30m</td>
</tr>
<tr class="odd">
<td>General tips for Parallel computing</td>
<td>20m</td>
</tr>
<tr class="even">
<td>Examples</td>
<td>20m</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="learning-goals">Learning goals<a class="anchor" aria-label="anchor" href="#learning-goals"></a>
</h3>
<ul>
<li>Understand how parallel computing works behind the scenes</li>
<li>Understand different parallel computing backends</li>
<li>Know how to use BiocParallel package to speed up your analysis</li>
<li>(Advanced) Be able to build your at-home computing cluster</li>
</ul>
</div>
<div class="section level3">
<h3 id="learning-objectives">Learning objectives<a class="anchor" aria-label="anchor" href="#learning-objectives"></a>
</h3>
<ul>
<li>Run <strong>bplapply</strong> function with different parallel
backends</li>
<li>Connect with a Redis server using RedisParam</li>
<li>Use BiocParallel to run a permutation algorithm with a backend of
your choice</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>With the recent “core war” between Intel and AMD, two major CPU
manufacturers, the number of cores in a CPU has been increasing rapidly.
For example, the latest AMD Ryzen 9 7950X is equipped with 16 cores and
32 threads. This monster-level CPU provides a huge amount of computing
power for performing large-scale data analysis. However, most of the
time, we are not using the full power of our CPU as R is designed as a
single-threaded programming language. This design makes R easy to learn
and use, but it also limits the computing power of R. In this workshop,
we will introduce how to use parallel computing to fully utilize the
power of your CPU and build your at-home computing cluster.</p>
<p>While parallel computing may sound fancy and complicated, it is very
simple at its core. Many packages in R can help you to do parallel
computing, and they all share the same basic idea: <strong>split a job
into smaller tasks and run them simultaneously</strong>. For example, if
you need to perform 1000 additions, you can either do it one by one by
yourself, or you can ask 10 friends to do 100 additions each(be sure to
treat them a nice dinner afterward). If you choose the latter, you are
doing parallel computing. In computer science, we usually call you the
“master” and your friends the “workers”. Without loss of generality,
parallel computing in R involves the following steps:</p>
<ol style="list-style-type: decimal">
<li>Start a master process</li>
<li>Start worker processes</li>
<li>Split a job into smaller tasks</li>
<li>Send tasks to workers</li>
<li>Receive and combine results from workers</li>
</ol>
<p>There are two important concept in parallel computing: cluster
structure and job-splitting scheme. The cluster structure decides where
to find the workers and how to communicate with them(steps 1,2, and 4).
The job-splitting scheme decides how to split a job into smaller tasks
and send them to the workers(step 3). The simplest cluster is shown in
the following figure: <img src="direct_connection.png" alt="Parallel Computing via Direct Connection"></p>
<p>The structure above shows a master R session connected with 4
workers. The key point of this structure is that the master and workers
can directly talk with each other without any message relay. The master
and workers can be in a single computer or different computers. However,
as you will see in the later section of this workshop, this structure
works best if both master and workers are in the same machine. The
situation will become complicated if you want to use multiple computers
as workers.</p>
<p>The job-splitting scheme decides how to split a job into smaller
tasks and send them to the workers. The job-splitting scheme is shown in
the following figure: <img src="job-splitting.png" alt="job-splitting structure"></p>
<p>In parallel computing, we call the thing you want to compute a “job”.
A job is usually a loop or a function that you want to run multiple
times. We split the job into smaller “tasks” and send them to the
workers. By doing this we can run multiple tasks simultaneously.</p>
<p>The cluster structure and job-splitting scheme give a big picture of
parallel computing. In practice, we find that it will be helpful to
think about the following three questions before you start your parallel
computing:</p>
<ol style="list-style-type: decimal">
<li>Where to create the workers</li>
<li>How do you communicate between the master and the workers</li>
<li>How the job will be splitted</li>
</ol>
<p>The answer to these three questions determines the best way to
construct your computing cluster and the best parallel function to
use.</p>
</div>
<div class="section level2">
<h2 id="parallalization-in-biocparallel">Parallalization In BiocParallel<a class="anchor" aria-label="anchor" href="#parallalization-in-biocparallel"></a>
</h2>
<p>The BiocParallel package is a parallel package developed and
maintained by the Bioconductor core team and its alumnus. It is a highly
customizable package equipped with modern design. Assume that you have a
poorly written function <code>square</code> that takes at least 1 second
to calculate the square of a number</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## A function that takes a long time to run</span></span>
<span><span class="va">square</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">x</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We want to calculate the square of the numbers from 1 to 8. There are
two ways to do this:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Method 1: for loop</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">8</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/message.html" class="external-link">message</a></span><span class="op">(</span><span class="fu">square</span><span class="op">(</span><span class="va">i</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#&gt; 1</span></span>
<span><span class="co">#&gt; 4</span></span>
<span><span class="co">#&gt; 9</span></span>
<span><span class="co">#&gt; 16</span></span>
<span><span class="co">#&gt; 25</span></span>
<span><span class="co">#&gt; 36</span></span>
<span><span class="co">#&gt; 49</span></span>
<span><span class="co">#&gt; 64</span></span>
<span></span>
<span><span class="co">## Method 2: lapply</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">8</span>, <span class="va">square</span><span class="op">)</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [1] 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [1] 9</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [1] 16</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[5]]</span></span>
<span><span class="co">#&gt; [1] 25</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[6]]</span></span>
<span><span class="co">#&gt; [1] 36</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[7]]</span></span>
<span><span class="co">#&gt; [1] 49</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[8]]</span></span>
<span><span class="co">#&gt; [1] 64</span></span></code></pre></div>
<p>With no surprise, both methods will take 8 seconds to finish. Since
calculating the square of a number is independent of each
other(e.g. square(1) does not depend on square(2)), we can parallelize
this code to speed up the calculation</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Load the BiocParallel package</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Bioconductor/BiocParallel" class="external-link">BiocParallel</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Define 4 workers</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/SnowParam-class.html" class="external-link">SnowParam</a></span><span class="op">(</span>worker <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## dispatch the job to workers, </span></span>
<span><span class="co">## each of them will execute the function foo twice</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">8</span>, <span class="va">square</span>, BPPARAM <span class="op">=</span> <span class="va">param</span><span class="op">)</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [1] 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [1] 9</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [1] 16</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[5]]</span></span>
<span><span class="co">#&gt; [1] 25</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[6]]</span></span>
<span><span class="co">#&gt; [1] 36</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[7]]</span></span>
<span><span class="co">#&gt; [1] 49</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[8]]</span></span>
<span><span class="co">#&gt; [1] 64</span></span></code></pre></div>
<p>The function <strong>SnowParam</strong> defines 4 workers that we are
going to use in the parallel computation. You do not have to explicitly
specify the argument <code>worker</code> in any <code>Param</code>
function, so <code>SnowParam(4)</code> will work equally well. In
BiocParallel, we call a cluster of workers a backend (as they are
working in the background). The master and workers communicate with each
other directly via a network protocol named SNOW(so the name SnowParam).
The cluster structure of this example is shown in the following figure:
<img src="Snow-structure.png" alt="SnowParam"></p>
<p>The function <strong>bplapply</strong> is a parallel version of the
<strong>lapply</strong> function. It dispatches 8 elements in the vector
<strong>1:8</strong> to 4 workers in the backend. If we use our
job-splitting schematic diagram, it will look like this</p>
<p><img src="job-splitting-example.png"></p>
<p>In this case, the master R will evenly split the 8 elements into 4
tasks and send them to the workers. Each worker will calculate the
square of 2 numbers and return their results. . In theorem, it will take
2 seconds to finish the calculation.</p>
<p>We can use <strong>system.time</strong> to benchmark the running time
of the <strong>lapply</strong> function and the
<strong>bplapply</strong> function</p>
<pre><code>&gt; system.time(lapply(1:8, square))
   user  system elapsed 
   0.00    0.00    8.06 
&gt; system.time(bplapply(1:8, square, BPPARAM = param))
   user  system elapsed 
   0.33    0.10    4.95 </code></pre>
<p>In my computer, it takes 8.06 seconds to finish the
<strong>lapply</strong> function and 4.95 seconds to finish the
<strong>bplapply</strong> function. We do see the improvement in running
time, but it is not as good as we expected. This is because there is
some overhead associated with parallelization. In this example, the cost
of parallelization is about 3 seconds. We will discuss how to improve
the performance of parallel computing later in this workshop, but for
now, let’s ignore it and think about the three questions we mentioned in
the previous section:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Where to create the workers</strong>: You possibly can
guess the answer to this question, we create 4 workers on the same
computer as the master process. There is no magic in computer science,
if you have one computer running your R code, there is no way for R to
“enslave” your neighbor’s computers to do your homework. So, the workers
must be on the same computer as the master process.</p></li>
<li><p><strong>How do you communicate between the master and the
workers</strong>: In this example, we are using a network protocol named
SNOW to communicate between the master and the workers(so the name
SnowParam). You don’t need to worry about the details of the socket
protocol, the parallel packages will take care of it for you.</p></li>
<li><p><strong>How the job will be splitted</strong>: In this example,
we evenly divived the job by the number of workers. This is the default
behavior of BiocParallel package. You can change the behavior by
specifying the argument <code>tasks</code> when creating the
SnowParam.</p></li>
</ol>
<p>In practice, question 1 and 2 are related. The location of the worker
determines the appropriate communication method between the master and
the workers. Generally speaking, it will be sufficient to use the
<strong>SnowParam</strong> function to do parallel computing on your
local computer. However, as your code becomes more computing-intensive,
you may want to connect with other computers to speed up the
calculation. We will introduce some other backends in the following
sections that will be helpful to solve a more complicated parallel
computing problem.</p>
<div class="section level3">
<h3 id="multicoreparam-linux-only-or-wsl2-for-win-users">MulticoreParam (Linux only, or WSL2 for Win Users)<a class="anchor" aria-label="anchor" href="#multicoreparam-linux-only-or-wsl2-for-win-users"></a>
</h3>
<p>MulticoreParam is similar to SnowParam, but it has the potential to
reduce the overhead associated with parallelization. Traditionally, if
we create a worker and give it a task, the worker will need the data to
do the calculation. This data will be sent by the master process to the
worker and takes a certain amount of memory. If we have 4 workers, we
will have 4 copies of the data. This is not a problem if the data is
small, but it will be a problem if the data is big. MulticoreParam is
used to alleviate this problem. MulticoreParam is a special type of
backend that allows workers and the master to share the same data in
memory(they must be on the same computer). This means that we only need
one copy of the data in memory. To define a MulticoreParam, you only
need to replace the SnowParam with MulticoreParam in the previous
example.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Define 4 workers</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/MulticoreParam-class.html" class="external-link">MulticoreParam</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## dispatch the job to workers, </span></span>
<span><span class="co">## each of them will execute the function foo twice</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">8</span>, <span class="va">square</span>, BPPARAM <span class="op">=</span> <span class="va">param</span><span class="op">)</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [1] 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [1] 9</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [1] 16</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[5]]</span></span>
<span><span class="co">#&gt; [1] 25</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[6]]</span></span>
<span><span class="co">#&gt; [1] 36</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[7]]</span></span>
<span><span class="co">#&gt; [1] 49</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[8]]</span></span>
<span><span class="co">#&gt; [1] 64</span></span></code></pre></div>
<p>You can see that changing the backend only requires changing the
definition of the param. The rest of the code is the same. This modern
design allows you to write your parallel code without being tied to a
specific backend. You can easily switch between different backends
without changing your code. This is a very important feature of the
BiocParallel package. The cluster structure of MulticoreParam is the
same as SnowParam. The only difference is how the workers get started
(This is not completely true, but it is good enough for our
workshop).</p>
</div>
<div class="section level3">
<h3 id="redisparam">RedisParam<a class="anchor" aria-label="anchor" href="#redisparam"></a>
</h3>
<p>Now you know how to create a tiny computing cluster in your local
computer. However, our demand for computing power is endless and we will
quickly find that a single computer is not enough to handle our
computing task. We are still able to use the SnowParam to create a
cluster with multiple computers as SNOW is a network protocol. In this
case, the cluster structure might become like this:</p>
<p><img src="snow-frame-multiple.png"></p>
<p>In this structure, we have three computers. Computer 1 has the master
process and computers 2 and 3 have two workers each. We use IP addresses
to communicate between the master and the workers. The IP address serves
as the address of the computer. It is like the address of your house. If
you want to send a letter to your friend, you need to know the address
of your friend. The same thing happens here. We need to know the IP
address of the worker’s computer(computers 2&amp;3) to talk to the
workers inside. With this schematic diagram, you will quickly find that
the SnowParam is cumbersome for a large cluster because:</p>
<ol style="list-style-type: decimal">
<li>Each worker computer must have a public IP address to access</li>
<li>The workers are not persistent, they will be killed when the master
process quits.</li>
<li>You need to set up an SSH server and keys for all workers in order
to start workers remotely (Remember that computers 2 and 3 might not be
physically accessible)</li>
</ol>
<p>These three problems hinder the usage of SnowParam when handling
larger computing clusters. RedisParam is designed for this case. Instead
of having direct communication between master and workers, RedisParam
put a Redis server in the middle. The diagram below shows the general
cluster structure of this kind of design</p>
<p><img src="RedisParam.png"></p>
<p>Note that the three components(master, Redis Server, and workers) in
the diagram can run in the same machine or different machines. However,
only the Redis Server is required to have a public IP address. The role
of the Redis server is similar to the role of Bioconductor Slack
workspace. If you have a question(computing job) and you want to get
help from the other developers(workers). Do you want to message each
developer individually? Possibly not, if we use this mode to ask
questions, you may need to send thousands of messages to get the answer
to your question. Meanwhile, our enthusiastic developers will be
overwhelmed by tons of questions as well. To prevent that happens,
Bioconductor hosts a Slack workspace for Q&amp;A. You are free to post
any question to a Slack channel, and our lovely developers will answer
whatever question they can answer. A similar thing happens to
<strong>RedisParam</strong> as well. A master process will send the job
to the Redis server. The workers will receive tasks from the Redis
server and do the calculation. By doing that, the lifecycle of the
workers is not tied to the master process, but to the Redis server. You
can even have more than one master process sharing a pool of workers,
just like everyone is welcome to ask questions in Slack.</p>
<div class="section level4">
<h4 id="set-up-redis-server">Set Up Redis Server<a class="anchor" aria-label="anchor" href="#set-up-redis-server"></a>
</h4>
<p>The use of RedisParam requires a little bit more work. We need to set
up a Redis server. The easiest way to do that is to use the docker image
of Redis. <a href="https://docs.docker.com/install/" class="external-link">Here</a> is the
instruction to install docker on your computer. You will need
WSL2(Windows Subsystem for Linux) if you are using Windows. After you
have installed docker, you can run the following command to start a
Redis server.</p>
<pre><code>docker run --name my-first-redis -p 6379:6379 -d redis redis-server --requirepass "bioc2023"</code></pre>
<p>The command above will start a <a href="https://hub.docker.com/_/redis" class="external-link">Redis server</a> on port 6379 with
password bioc2023. The port number 6379 is the default port used by the
Redis server. We use <code>-p 6379:6379</code> to open that port to the
outside world, so you can access the Redis server in the container from
your computer.</p>
<p>Alternatively, you might want to host the Redis server in the cloud.
You can find the container service through all major cloud service
providers such as Azure and Amazon. In this workshop, we provide a
pre-configured Redis server running in the background in the workshop
container. You are ready to go if you are using the workshop
container</p>
</div>
<div class="section level4">
<h4 id="run-master-and-workers-in-the-same-computer">Run master and workers in the same computer<a class="anchor" aria-label="anchor" href="#run-master-and-workers-in-the-same-computer"></a>
</h4>
<p>If you have the Redis server running on your computer. You can use
the following code to create a RedisParam cluster.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">RedisParam</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Define 4 workers using Redis server</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/RedisParam/man/RedisParam-class.html" class="external-link">RedisParam</a></span><span class="op">(</span></span>
<span>  workers <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  redis.password <span class="op">=</span> <span class="st">'bioc2023'</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Test the cluster</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="va">square</span>, BPPARAM <span class="op">=</span> <span class="va">param</span><span class="op">)</span></span></code></pre></div>
<p>The code is not that different from the SnowParam and MulticoreParam.
The RedisParam will create 4 workers that connect to the Redis server on
localhost(your computer) using the password bioc2023. If we use the
cluster structure diagram, it will look like this:</p>
<p><img src="RedisParam-single.png"></p>
<p>All three components(master, Redis server, and workers) are in the
same machine. There is no need to use RedisParam if we only have one
computer. We will introduce how to run master and workers on different
computers in the next section.</p>
</div>
<div class="section level4">
<h4 id="run-master-and-workers-in-different-computers">Run Master and Workers in Different Computers<a class="anchor" aria-label="anchor" href="#run-master-and-workers-in-different-computers"></a>
</h4>
<p>The real power of RedisParam comes in when you want to connect with
multiple computers to create a large cluster. In this case, you need a
Redis server that is accessible by all the computers (Otherwise, how can
they talk to each other?). There are two things you need for using
RedisParam</p>
<ol style="list-style-type: decimal">
<li>the IP address of the Redis server.</li>
<li>The name of the job queue shared by master and workers</li>
</ol>
<p>We have discussed the idea of the IP address in the previous section.
The job queue is a new concept here. A job queue is like a channel in
Slack, it’s a place where you can post your question and get answers
from other developers. A master process can only be in one job queue at
a time. It can post its computing tasks to the job queue. The workers
enrolled in the same job queue will retrieve the tasks from the job
queue and execute them. Multiple master processes can enroll in the same
job queue. Therefore, they can share the same pool of workers. A Redis
server can have multiple job queues running at the same time without
interfering with each other. Just like a Slack workspace can have
multiple channels at the same time.</p>
<div class="section level5">
<h5 id="start-workers">Start Workers<a class="anchor" aria-label="anchor" href="#start-workers"></a>
</h5>
<p>In this workshop, we will set up a remote Redis server for you. We
ask you to “donate” some workers to our demo job queue.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Redis server IP. To be announced in the workshop</span></span>
<span><span class="va">host</span> <span class="op">&lt;-</span> <span class="st">'remote-Ip-address'</span></span>
<span></span>
<span><span class="co">## Define how many workers you want to "donate"</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/RedisParam/man/RedisParam-class.html" class="external-link">RedisParam</a></span><span class="op">(</span></span>
<span>  workers <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  redis.hostname <span class="op">=</span> <span class="va">host</span>,</span>
<span>  redis.password <span class="op">=</span> <span class="st">'bioc2023'</span>,</span>
<span>  jobname <span class="op">=</span> <span class="st">"demo"</span>,</span>
<span>  is.worker <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Start the worker</span></span>
<span><span class="co">## This will block the entire R session</span></span>
<span><span class="co">## You CANNOT use ctrl + c to stop the worker</span></span>
<span><span class="co">## Don't be panic, I will free you after a minute</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/BiocParallelParam-class.html" class="external-link">bpstart</a></span><span class="op">(</span><span class="va">param</span><span class="op">)</span></span></code></pre></div>
<p>A few new things to note here. We use <strong>redis.hostname</strong>
to specify the IP address of the Redis server. We use
<strong>jobname</strong> to specify the job queue we want to use. The
job queue is identified by a character name. We use <strong>is.worker =
TRUE</strong> to tell RedisParam that we want to start two workers. If
<strong>is.worker = FALSE</strong>, the argument
<strong>workers</strong> will be ignored and the backend will be used as
a master. If we do not specify the argument <strong>is.worker</strong>,
The backend will contain both master and workers by default. The cluster
diagram of the current setup is shown below.</p>
<p><img src="RedisParam-multiple.png"></p>
<p>This will be the most complicated cluster we will build in this
workshop. You can see the power of RedisParam: The master and workers
can be in different computers. The master and workers can be in
different physical locations. The number of workers can be dynamic. As
long as the Redis server is accessible by all the computers, they can
form a cluster.</p>
</div>
<div class="section level5">
<h5 id="start-a-master">Start a master<a class="anchor" aria-label="anchor" href="#start-a-master"></a>
</h5>
<p>Creating a master is similar to creating a worker. The only
difference is that we set <strong>is.worker = FALSE</strong>. We create
a random job name so that all of us can share the same Redis server to
do the computation.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Redis server IP. To be announced in the workshop</span></span>
<span><span class="va">host</span> <span class="op">&lt;-</span> <span class="st">'remote-Ip-address'</span></span>
<span></span>
<span><span class="co">## Create a ramdom jobname</span></span>
<span><span class="va">jobname</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/ipcmutex.html" class="external-link">ipcid</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/message.html" class="external-link">message</a></span><span class="op">(</span><span class="st">"My job queue: "</span>, <span class="va">jobname</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Create a master param</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/RedisParam/man/RedisParam-class.html" class="external-link">RedisParam</a></span><span class="op">(</span></span>
<span>  redis.hostname <span class="op">=</span> <span class="va">host</span>,</span>
<span>  redis.password <span class="op">=</span> <span class="st">'bioc2023'</span>,</span>
<span>  jobname <span class="op">=</span> <span class="va">jobname</span>,</span>
<span>  is.worker <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Note that this master <code>param</code> <strong>cannot</strong> be
used to do the computation right now, as the job queue is not monitored
by any workers (You wouldn’t expect to get any message from a Slack
channel with no members, right?). You need the code from the previous
section to start your worker elsewhere and connect with the same job
queue. While the order of starting the master and workers doesn’t
matter, you need to have your workers ready before you use your master
param to do the actual computation.</p>
</div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="mind-map">Mind Map<a class="anchor" aria-label="anchor" href="#mind-map"></a>
</h2>
<p>Below is the mind map that can help you choose different parallel
backends. Please note that this mind map serves as a recommendation
only. You can always try different parallel backends to see which one
works best for you.</p>
<p><img src="mind-map.png"></p>
</div>
<div class="section level2">
<h2 id="special-topics">Special Topics<a class="anchor" aria-label="anchor" href="#special-topics"></a>
</h2>
<div class="section level3">
<h3 id="additional-argument">Additional Argument<a class="anchor" aria-label="anchor" href="#additional-argument"></a>
</h3>
<p>It is very common to have additional arguments in an R function. For
example, if we have an add function <code>add</code> that takes two
arguments <code>x</code> and <code>y</code></p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">add</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">x</span> <span class="op">+</span> <span class="va">y</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>In <code>bplapply</code>, the second argument <code>y</code> in
<code>add</code> can be set by passing a (named) argument to
<code>...</code> in <code>bplapply</code></p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="va">add</span>, y <span class="op">=</span> <span class="fl">1</span>, BPPARAM <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/SnowParam-class.html" class="external-link">SnowParam</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [1] 2</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [1] 3</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [1] 5</span></span></code></pre></div>
<p>You can pass as many arguments as you need after specifying the
function you are applying in <code>bplapply</code> (in our case, it is
the function <code>add</code>). Although the argument name is not
required, we recommend you use it for clarity.</p>
</div>
<div class="section level3">
<h3 id="error-handling">Error Handling<a class="anchor" aria-label="anchor" href="#error-handling"></a>
</h3>
<p>In practice, it is inevitable to have bugs in your code. The
<code>bplapply</code> function will stop if it encounters an error.
Reading the error message can help you to better debug the code.
However, the error is not always understandable. We provide three
general tips to help you debug the code</p>
<ol style="list-style-type: decimal">
<li>Shortening the first argument <code>X</code> in
<code>bplapply</code>
</li>
<li>Start with a smaller worker number</li>
<li>Try SerialParam</li>
</ol>
<div class="section level4">
<h4 id="shortening-the-first-argument-x-in-bplapply">Shortening the first argument <code>X</code> in
<code>bplapply</code><a class="anchor" aria-label="anchor" href="#shortening-the-first-argument-x-in-bplapply"></a>
</h4>
<p>Shortening the first argument <code>X</code> in <code>bplapply</code>
not only reduces the time you will need to wait until observing an
error. It also simplifies the code you are trying to debug. If you want
to ask others for help. Having a short and reproducible code is always a
good idea.</p>
</div>
<div class="section level4">
<h4 id="start-with-a-smaller-worker-number">Start with a smaller worker number<a class="anchor" aria-label="anchor" href="#start-with-a-smaller-worker-number"></a>
</h4>
<p>Since each worker takes a certain amount of resources, the error may
be caused by the lack of resources (E.g. insufficient memory). Starting
with a smaller worker number can help you to exclude this possibility.
Meanwhile, having a smaller number of workers can make it easier for
others to run your code(e.g. no one wants to reproduce your error with
128 workers).</p>
</div>
<div class="section level4">
<h4 id="try-serialparam">Try SerialParam<a class="anchor" aria-label="anchor" href="#try-serialparam"></a>
</h4>
<p>If you are not sure whether the error is caused by the workers, you
can try to use <code>SerialParam</code> to run your code in a single
process. <code>SerialParam</code> is a special backend that does not use
any parallel computing and runs your code in the current R session. You
can even use a debugger to debug your code. For example, you can debug
the <code>add</code> function during the single-threaded parallel
computing by using the following code</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">add2</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/browser.html" class="external-link">browser</a></span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="va">x</span> <span class="op">+</span> <span class="va">y</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="va">add2</span>, <span class="fl">1</span>, BPPARAM <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/SerialParam-class.html" class="external-link">SerialParam</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>The R session will stop before executing <code>x + y</code></p>
</div>
</div>
<div class="section level3">
<h3 id="loading-balance">Loading balance<a class="anchor" aria-label="anchor" href="#loading-balance"></a>
</h3>
<p>In some cases, the function execution time can be uneven. For
example, if we have the following code</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wait</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="va">i</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="va">wait</span>, BPPARAM <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/SnowParam-class.html" class="external-link">SnowParam</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Even without overhead in parallel computing, the code above will take
7 seconds to finish. The reason is that the second worker needs to
calculate <code>wait(3)</code> and <code>wait(4)</code>. It will cause
the second worker to sleep for 7 seconds. Although the first worker only
needs 3 seconds to finish. <code>bplapply</code> must wait until all the
workers finish their jobs. We call this situation <strong>unbalanced
loading</strong>.</p>
<p>One solution for solving unbalanced loading is to increase the
granularity of the task. Recall that <code>bplapply</code> will split
the first argument <code>X</code> into smaller pieces(tasks) and assign
them to the workers. The number of tasks is equal to the number of
workers by default. However, we can force it to create more tasks than
the workers by setting the argument <code>tasks</code> in
<code>SnowParam</code>. For example, the code below will create 4 tasks
for 2 workers.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="va">wait</span>, BPPARAM <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/SnowParam-class.html" class="external-link">SnowParam</a></span><span class="op">(</span><span class="fl">2</span>, task <span class="op">=</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>If you want each task to contain exactly one element of
<code>X</code>, you can set <code>task=.Machine$integer.max</code>.
However, please note that this will increase the overhead in parallel
computing.</p>
</div>
<div class="section level3">
<h3 id="progress-bar">Progress bar<a class="anchor" aria-label="anchor" href="#progress-bar"></a>
</h3>
<p>Enabling the progress bar is very easy. You just need to set
<code>progressbar = TRUE</code> in <code>SnowParam</code>. However, the
progress bar can only be updated when a worker returns a result. Since a
worker only returns results when it completes a task, you might observe
a “bump” in the progress bar each time a worker completes a task. To
have a smoother progress bar, you need to consider to increase the
granularity of the task. The code below shows the most smooth progress
bar you can get with <code>bplapply</code></p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Each task will have exactly one element</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/SnowParam-class.html" class="external-link">SnowParam</a></span><span class="op">(</span><span class="fl">2</span>, task <span class="op">=</span> <span class="va">.Machine</span><span class="op">$</span><span class="va">integer.max</span>, progressbar <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">## The progress bar will be updated when a wait function completes</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="va">wait</span>, BPPARAM <span class="op">=</span> <span class="va">param</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="optimization">optimization<a class="anchor" aria-label="anchor" href="#optimization"></a>
</h3>
<p>To optimize the performance of parallel computing, you need to
understand the source of overhead in parallel computing. There are four
parts of overhead in parallel computing</p>
<ol style="list-style-type: decimal">
<li>Worker creation</li>
<li>Data transfer</li>
<li>Job splitting</li>
<li>Worker environment preparation</li>
</ol>
<p>While items 3 and 4 are handled internally in BiocParallel and thus
unavoidable, you can reduce the overhead from items 1 and 2 by using the
following tips. Note that the tips are for <code>SnowParam</code>. If
you are using <code>MulticoreParam</code>, the overhead of items 1 and 2
are negligible and therefore there is no need to optimize them.</p>
<div class="section level4">
<h4 id="create-workers-in-advance">Create workers in advance<a class="anchor" aria-label="anchor" href="#create-workers-in-advance"></a>
</h4>
<p>Creating workers is a time-consuming process. If we do not explicitly
create workers, <code>bplapply</code> will create workers when it is
called and stop the workers when it finishes. Therefore, if you want to
call <code>bplapply</code> repeatedly, you might want to create workers
in advance to avoid the overhead of worker creation. The code below
shows how to manually create workers</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Define a SnowParam backend</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/SnowParam-class.html" class="external-link">SnowParam</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Manually Create workers</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/BiocParallelParam-class.html" class="external-link">bpstart</a></span><span class="op">(</span><span class="va">param</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Run a parallel computing job</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="va">add</span>, y <span class="op">=</span> <span class="fl">1</span>, BPPARAM <span class="op">=</span> <span class="va">param</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Manually stop workers</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/BiocParallelParam-class.html" class="external-link">bpstop</a></span><span class="op">(</span><span class="va">param</span><span class="op">)</span></span></code></pre></div>
<p>We can also time the code above to see the overhead of worker
creation</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Parallel code without worker creation</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="va">add</span>, y <span class="op">=</span> <span class="fl">1</span>, BPPARAM <span class="op">=</span> <span class="va">param</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<pre><code>user  system elapsed 
0.62    0.08    2.09 </code></pre>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Parallel code with worker creation in advance</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/BiocParallelParam-class.html" class="external-link">bpstart</a></span><span class="op">(</span><span class="va">param</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="va">add</span>, y <span class="op">=</span> <span class="fl">1</span>, BPPARAM <span class="op">=</span> <span class="va">param</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/BiocParallelParam-class.html" class="external-link">bpstop</a></span><span class="op">(</span><span class="va">param</span><span class="op">)</span></span></code></pre></div>
<pre><code>user  system elapsed 
0.21    0.03    0.48 </code></pre>
<p>In Rstudio, it takes about 1.5 seconds to create 2 workers. The cost
will be more significant if you have more workers, or if the workers are
created in a remote machine.</p>
</div>
<div class="section level4">
<h4 id="avoid-data-transfer">Avoid data transfer<a class="anchor" aria-label="anchor" href="#avoid-data-transfer"></a>
</h4>
<p>Data transfer is another source of overhead in parallel computing. It
is especially significant when the data is large. Data transfer should
be kept to a minimum level if possible. A general strategy is to avoid
using a large R object during parallel computing. However, we understand
this requires a redesign of the algorithm and is not always possible. In
this section, we provide a simple tip that can reduce the data transfer
in some cases. You can disable exporting R environment variables by
setting <code>exportglobals = FALSE</code> in
<code>SnowParam</code>.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/SnowParam-class.html" class="external-link">SnowParam</a></span><span class="op">(</span><span class="fl">2</span>, exportglobals <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>This will prevent <code>bplapply</code> from exporting the R
environment variables to the workers. It is especially important when
you are using RStudio as RStudio will define many environment variables
for you.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="examples">Examples<a class="anchor" aria-label="anchor" href="#examples"></a>
</h2>
<div class="section level3">
<h3 id="example-1-monte-carlo-simulation">Example 1: Monte Carlo Simulation<a class="anchor" aria-label="anchor" href="#example-1-monte-carlo-simulation"></a>
</h3>
<p>Parallel computing is usually used in simulation and permutation. In
this example, we will use simulation to demonstrate the parallel
computing. We want to calculate the distribution of the T statistic
given that the null hypothesis is true(group means are equal)</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Sample size for each group</span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">10000</span></span>
<span></span>
<span><span class="co">## Simulate from the uniform distribution</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Calculate t statistic</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/t.test.html" class="external-link">t.test</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">y</span><span class="op">)</span><span class="op">$</span><span class="va">statistic</span></span>
<span><span class="co">#&gt;          t </span></span>
<span><span class="co">#&gt; -0.2924725</span></span></code></pre></div>
<p>The code above generates two samples from the uniform distribution
and calculates the t statistic. We wrap the code in a function so that
we can use it in the parallel backend</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mySim</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">i</span>, <span class="va">n</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span></span>
<span>  <span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/t.test.html" class="external-link">t.test</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">y</span><span class="op">)</span><span class="op">$</span><span class="va">statistic</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Note that the argument <code>i</code> is purely for the
<code>bplapply</code> function and does not have any meaning. Suppose we
want to repeat the simulation 10000 times, we first use the
<code>lapply</code> function to measure the baseline time</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span></span>
<span>   <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">10000</span>, <span class="va">mySim</span>, n <span class="op">=</span> <span class="va">n</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code>user  system elapsed 
7.92    1.00    8.91</code></pre>
<p>In my computer, it takes about 9 seconds to finish the computation.
Now we use <code>bplapply</code> to do the same thing and see the
performance improvement using all the optimization methods we have
learned so far</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Bioconductor/BiocParallel" class="external-link">BiocParallel</a></span><span class="op">)</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/SnowParam-class.html" class="external-link">SnowParam</a></span><span class="op">(</span><span class="fl">10</span>, exportglobals <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/BiocParallelParam-class.html" class="external-link">bpstart</a></span><span class="op">(</span><span class="va">param</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="op">{</span></span>
<span>    <span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">10000</span>, <span class="va">mySim</span>, n <span class="op">=</span> <span class="va">n</span>, BPPARAM<span class="op">=</span><span class="va">param</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/BiocParallelParam-class.html" class="external-link">bpstop</a></span><span class="op">(</span><span class="va">param</span><span class="op">)</span></span></code></pre></div>
<pre><code>user  system elapsed 
0.23    0.00    1.47 </code></pre>
<p>It takes about 1.5 seconds to finish. We can see that the performance
is improved by a factor of 6. The performance improvement is not as good
as we expected. This is because the simulation is still too simple and
the overhead of parallel computing is large compared to the actual
computation. However, as the tasks get more complicated, the performance
improvement will be more significant.</p>
</div>
<div class="section level3">
<h3 id="example-2-permutation-for-finding-the-null-distribution">Example 2: Permutation for Finding the Null Distribution<a class="anchor" aria-label="anchor" href="#example-2-permutation-for-finding-the-null-distribution"></a>
</h3>
<p>In this example, we will do a permutation to show the conditional
null distribution of the Berk-Jone statistic. The Berk-Jones statistic
is designed to test if a set of p-values are from a uniform
distribution. In other words, it aims to test if all p-values are from
the null distribution. It is known that calculating the exact
distribution of Berk-Jones statistic is computationally intensive.
Therefore, we will use the permutation method to approximate the
distribution. Below is the code to calculate the Berk-Jone
statistics</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">BJStat</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">samples</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">samples</span><span class="op">[</span><span class="va">samples</span><span class="op">==</span><span class="fl">0</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1e-10</span></span>
<span>  <span class="va">samples</span><span class="op">[</span><span class="va">samples</span><span class="op">==</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">-</span><span class="fl">1e-10</span></span>
<span>  <span class="va">samples</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="va">samples</span><span class="op">)</span></span>
<span>  <span class="va">i</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_along</a></span><span class="op">(</span><span class="va">samples</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Beta.html" class="external-link">pbeta</a></span><span class="op">(</span><span class="va">samples</span>, <span class="va">i</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">samples</span><span class="op">)</span><span class="op">-</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Test the function</span></span>
<span><span class="co">## Small value implies the significance</span></span>
<span><span class="fu">BJStat</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.484119</span></span></code></pre></div>
<p>We will use <code>airway</code> data in the airway package as an
example. We first load the data into R.</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://bioconductor.org/packages/SummarizedExperiment" class="external-link">SummarizedExperiment</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">airway</span>, package<span class="op">=</span><span class="st">"airway"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Counts matrix</span></span>
<span><span class="co">## Row: RNA-Seq reads</span></span>
<span><span class="co">## Column: samples</span></span>
<span><span class="va">counts</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">assays</a></span><span class="op">(</span><span class="va">airway</span><span class="op">)</span><span class="op">$</span><span class="va">counts</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">counts</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 63677     8</span></span>
<span></span>
<span><span class="co">## Treatment group</span></span>
<span><span class="va">groups</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">colData</a></span><span class="op">(</span><span class="va">airway</span><span class="op">)</span><span class="op">$</span><span class="va">dex</span></span>
<span><span class="va">groups</span></span>
<span><span class="co">#&gt; [1] untrt trt   untrt trt   untrt trt   untrt trt  </span></span>
<span><span class="co">#&gt; Levels: trt untrt</span></span></code></pre></div>
<p>The variable <code>counts</code> has 63677 rows and 8 columns. Each
row represents a gene and each column represents a sample. The variable
<code>groups</code> is a factor variable that indicates the treatment
group of each sample.</p>
<p>We will use DESeq pipeline to perform a negative binomial test and
obtain the p-value for each gene. Because we will reuse the pipeline
many times in the permutation, we can wrap the pipeline into a
function.</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## my negative binomial test</span></span>
<span><span class="va">myNBTest</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">counts</span>, <span class="va">groups</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/mikelove/DESeq2" class="external-link">DESeq2</a></span><span class="op">)</span></span>
<span>    <span class="co"># Create a data frame for the grouping variable</span></span>
<span>    <span class="va">colData</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>group <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="va">groups</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="co"># Create a DESeqDataSet object</span></span>
<span>    <span class="va">dds</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/DESeq2/man/DESeqDataSet.html" class="external-link">DESeqDataSetFromMatrix</a></span><span class="op">(</span>countData <span class="op">=</span> <span class="va">counts</span>,</span>
<span>                                  colData <span class="op">=</span> <span class="va">colData</span>,</span>
<span>                                  design <span class="op">=</span> <span class="op">~</span> <span class="va">group</span><span class="op">)</span></span>
<span>    <span class="co"># Run the DESeq pipeline</span></span>
<span>    <span class="va">dds</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/DESeq2/man/DESeq.html" class="external-link">DESeq</a></span><span class="op">(</span><span class="va">dds</span>, quiet<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span>    <span class="co"># Get the results</span></span>
<span>    <span class="va">pvalues</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/DESeq2/man/results.html" class="external-link">results</a></span><span class="op">(</span><span class="va">dds</span><span class="op">)</span><span class="op">$</span><span class="va">pvalue</span> </span>
<span>    <span class="co"># Exclude NA values</span></span>
<span>    <span class="va">pvalues</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">pvalues</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We can put everything together and perform the Berk-Jones test on the
p-values.</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pvalues</span> <span class="op">&lt;-</span> <span class="fu">myNBTest</span><span class="op">(</span><span class="va">counts</span>, <span class="va">groups</span><span class="op">)</span></span>
<span><span class="co">## Histogram</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">pvalues</span><span class="op">)</span></span></code></pre></div>
<p><img src="workshop_files/figure-html/unnamed-chunk-28-1.png" width="700"></p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Test if all p-values are from the uniform distribution</span></span>
<span><span class="fu">BJStat</span><span class="op">(</span><span class="va">pvalues</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0</span></span></code></pre></div>
<p>Now we have all the ingredients ready, we can start the permutation.
We will randomly shuffle the group labels and perform the Berk-Jones
test on the shuffled data. We wrap the permutation into a function.</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">myPermutation</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">i</span>, <span class="va">counts</span>, <span class="va">groups</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">## Randomly shuffle the group labels</span></span>
<span>  <span class="va">groups</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="va">groups</span><span class="op">)</span></span>
<span>  <span class="co">## Perform the Berk-Jones test</span></span>
<span>  <span class="va">pvalues</span> <span class="op">&lt;-</span> <span class="fu">myNBTest</span><span class="op">(</span><span class="va">counts</span>, <span class="va">groups</span><span class="op">)</span></span>
<span>  <span class="co">## Return the Berk-Jones statistic</span></span>
<span>  <span class="fu">BJStat</span><span class="op">(</span><span class="va">pvalues</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>The variable <code>i</code> is purely for the <code>bplapply</code>
function and does not have any effect. Let’s test and benchmark our
permutation function</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="va">res</span> <span class="op">&lt;-</span> <span class="fu">myPermutation</span><span class="op">(</span><span class="va">i</span>, <span class="va">counts</span>, <span class="va">groups</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<pre><code>   user  system elapsed 
  10.14    0.19   10.34 </code></pre>
<p>It takes 10 seconds for a single permutation. We will try to permute
the data 50 times in a parallel fashion. The parallel code is shown
below.</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Bioconductor/BiocParallel" class="external-link">BiocParallel</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co">## I use 10 workers in my computer</span></span>
<span><span class="co">## You might want a different number</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/SnowParam-class.html" class="external-link">SnowParam</a></span><span class="op">(</span><span class="fl">10</span>, exportglobals <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/BiocParallelParam-class.html" class="external-link">bpstart</a></span><span class="op">(</span><span class="va">param</span><span class="op">)</span></span>
<span></span>
<span><span class="co">## Repeat permutation 100 times</span></span>
<span><span class="co">## and return a vector</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/bplapply.html" class="external-link">bplapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">100</span>, <span class="va">myPermutation</span>, <span class="va">counts</span>, <span class="va">groups</span>, BPPARAM<span class="op">=</span><span class="va">param</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/BiocParallelParam-class.html" class="external-link">bpstop</a></span><span class="op">(</span><span class="va">param</span><span class="op">)</span></span></code></pre></div>
<pre><code>user  system elapsed 
0.20    0.09  128.84 </code></pre>
<p>In my computer, it takes 128 seconds to finish. It is estimated that
the single-threaded <code>lapply</code> will take 1000 seconds to finish
the same computing job. We have about 7.8 times speedup. We are one step
closer to the theoretical speedup of 10.</p>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p><a href="mailto:szwjf08@gmail.com" class="email">szwjf08@gmail.com</a><a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Jiefei Wang.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
